// Module:
// Notices: Copyright(c) 2016 Jim Jian.
// Purpose:
// Compiler: Embarcadero RAD Studio XE8
// OS: Windows 8.1 x64
// Version: 0.1.0.6
//---------------------------------------------------------------------------

//#include <vcl.h>
#pragma hdrstop

#include "MSG_DIALOG.h"
#include "Main.h"
#include "DeviceNotify.h"
#include "Hub_fun.h"
#include "logging.h"
#include "Info.h"
#include "UnitUSB.h"

//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TfrmMain *frmMain;
Port_test *PORT = new Port_test();
Tmessagebox_form *SETBOX, *RESETMACBOX;
HANDLE lan, threadwork, mac;
DeviceNotification g_DeviceNogification;
clock_t start, end;
AnsiString Buildday = "PingTool ver 1.0.0 B20171120";
AnsiString RUNTIME;		//程式開始執行時間(yymmddhhmmss)
AnsiString LOGFILE, INIFILE; //存檔路徑
FILE * fp;
AnsiString ERRMSG;
AnsiString GETMAC="";   //紀錄 系統讀取 MAC Address
AnsiString SETMAC="";   //紀錄 燒錄ASIX MAC Address
AnsiString HOSTIP="";   //紀錄 本機 IP Address
AnsiString DHCPIP="";   //紀錄 DHCP IP Address
bool PROGPass, ReadGood, isEC, CHKERR, GETDEVICE;
void SaveLogLing(AnsiString FileName,AnsiString FileLine);
AnsiString deviceVPID;
AnsiString lanname;
int windowsVer;
DWORD TestTime = 0;

#define IOCTL_EEPROM_READ_DATA			CTL_CODE (FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_EEPROM_WRITE_DATA			CTL_CODE (FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_EFUSE_READ_DATA			CTL_CODE (FILE_DEVICE_UNKNOWN, 0x802, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_EFUSE_WRITE_DATA			CTL_CODE (FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_EEPROM_CHANGE_DELAY       CTL_CODE (FILE_DEVICE_UNKNOWN, 0x816, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_GET_DEVICE				CTL_CODE (FILE_DEVICE_UNKNOWN, 0x80F, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SPEED_CHANGE				CTL_CODE (FILE_DEVICE_UNKNOWN, 0x810, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CHECK_LINK				CTL_CODE (FILE_DEVICE_UNKNOWN, 0x811, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SET_TO_MAC_MODE			CTL_CODE (FILE_DEVICE_UNKNOWN, 0x821, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SET_TO_PHY_MODE			CTL_CODE (FILE_DEVICE_UNKNOWN, 0x822, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_WRITE_MAC_REGISTER		CTL_CODE (FILE_DEVICE_UNKNOWN, 0x830, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_READ_MAC_REGISTER			CTL_CODE (FILE_DEVICE_UNKNOWN, 0x831, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_WRITE_PHY_REGISTER		CTL_CODE (FILE_DEVICE_UNKNOWN, 0x840, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_READ_PHY_REGISTER			CTL_CODE (FILE_DEVICE_UNKNOWN, 0x841, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_WRITE_USBDC_REGISTER		CTL_CODE (FILE_DEVICE_UNKNOWN, 0x850, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_READ_USBDC_REGISTER		CTL_CODE (FILE_DEVICE_UNKNOWN, 0x851, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SET_WAKEUP_FRAME			CTL_CODE (FILE_DEVICE_UNKNOWN, 0x860, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DEVICE_CYCLE_PORT_179		CTL_CODE (FILE_DEVICE_UNKNOWN, 0x861, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DEVICE_CYCLE_PORT_772		CTL_CODE (FILE_DEVICE_UNKNOWN, 0x8A0, METHOD_BUFFERED, FILE_ANY_ACCESS)

//MAC 燒錄區段 開始~結束 字元
unsigned char MA5=0x00;
unsigned char MA4=0x01;
unsigned char MA3=0x8E;
unsigned char MA2=0x04;
unsigned char MA1=0x00;
unsigned char MA0=0x00;
unsigned char ME2=0x04;
unsigned char ME1=0x00;
unsigned char ME0=0x00;

unsigned char MR5,MR4,MR3,MR2,MR1,MR0;

GUID guid;
//---------------------------------------------------------------------------
__fastcall TfrmMain::TfrmMain(TComponent* Owner)
	: TForm(Owner)
{
	OldFormWndProc = this->WindowProc;
	this->WindowProc = FormWndProc;
	// 註冊USB裝置
	guid =StringToGUID("{A5DCBF10-6530-11D2-901F-00C04FB951ED}");
	g_DeviceNogification.RegisterWindowsDeviceInterfaceNotification(
		Handle,guid);//	GUID_CLASS_USB_DEVICE_USB);
}

void __fastcall TfrmMain::FormWndProc(TMessage& Message) // 攔截設備訊息
{
	PDEV_BROADCAST_DEVICEINTERFACE pDevInf;
	OldFormWndProc(Message);
	if (Message.Msg == WM_DEVICECHANGE) { // 有設備拔插
		if (!TestWorking) {
			pDevInf = PDEV_BROADCAST_DEVICEINTERFACE(Message.LParam);
			if (Message.WParam == DBT_DEVICEARRIVAL) // 新插入了一項裝置!
			{
				if(pDevInf->dbcc_classguid == guid){
					AnsiString dbccname = pDevInf->dbcc_name;
					bool deviceout;
					lanname = "NULL";
					int timeout = 0;
					while(lanname == "NULL"){
						if(timeout == 50)
						break;
						lanname = PORT->GetLANName();
						timeout++;
						PORT->Delay(100);
					}
					if(lanname == "NULL"){
						lab_devicename->Caption = "";
						current_mac->Caption = "未插入設備";
					}
					else{
						deviceVPID = PORT->GetLanPVID(lanname);
						if(dbccname.Pos(deviceVPID)){
							deviceout = PORT->FindDevice(deviceVPID);
						}
					}
				}
			}
			if (Message.WParam == DBT_DEVICEREMOVECOMPLETE) // 新拔出了一項裝置!
			{
				if(pDevInf->dbcc_classguid == guid){
					AnsiString dbccname = pDevInf->dbcc_name;
					bool deviceout;
					deviceout = PORT->FindDevice(deviceVPID);
					if(!deviceout){
						Panel_mac->Color = clWhite;
						Panel_lan->Color = clWhite;
						Panel_lan->Caption = "Wait";
						pan_10->Color = clWhite;
						pan_100->Color = clWhite;
						pan_1000->Color = clWhite;
						frmMain->Height = 255;
						plErrMsg->Caption = "";
						lab_devicename->Caption = "";
						frmMain->lab_time->Caption = "0";
						current_mac->Caption = "未插入設備";
						HaveDevice = false;
					}
				}
			}
		}
	}
}


DWORD WINAPI ThreadWorkExecute(LPVOID Param){
	int Step = 0, costTime = 0;
	while (frmMain->TestWorking){
		switch (Step) {
		case 0 :
			lanname = PORT->GetLANName();
			if(lanname != "NULL")
			{
				deviceVPID = PORT->GetLanPVID(lanname);

				frmMain->TestResult = true;
				frmMain->HaveDevice = true;
				frmMain->current_mac->Caption = PORT->getLanMAC(lanname); //顯示當前設備號
				Step = 1;
			}
			else
			{
				frmMain->lab_devicename->Caption = "";
				frmMain->current_mac->Caption = "未插入設備";
			}
			break;
		case 1:
			frmMain->Panel_lan->Caption = "Testing";
			if(PORT->Findfilemsg("TEST_TOOL\\infomation.txt",
						"TEST ITEM", 2)=="LAN_true" && frmMain->TestResult){  //補燒不測網路取消   20160505   jim
				if(frmMain->CHIPSET == "AX88179"){
					//偵測AX88179 是否為USB3.0線路
					if(PORT->Analyze_USBView("0B95", "1790")){
						//網路測試
						strcpy(zTestResult[1].name, "LAN");
						lan = ::CreateThread(0, 1024, LANExecute, (LPVOID) & zTestResult[1], 0,
							NULL);
							WaitForSingleObject(lan, INFINITE);
							CloseHandle(lan);
					}else{
						frmMain->pan_1000->Color = clRed;
						frmMain->TestResult = false;
						frmMain->Panel_lan->Color = clRed;
						frmMain->Panel_lan->Caption = "FAIL";
						frmMain->Height = 289;
						frmMain->plErrMsg->Caption = "USB3.0 FAIL";
					}
				}else if(frmMain->CHIPSET == "Realtek"){
					if(PORT->Analyze_USBView("0BDA", "8153")){
						//網路測試
						strcpy(zTestResult[1].name, "LAN");
						lan = ::CreateThread(0, 1024, LANExecute, (LPVOID) & zTestResult[1], 0,
							NULL);
							WaitForSingleObject(lan, INFINITE);
							CloseHandle(lan);
					}else{
						frmMain->pan_1000->Color = clRed;
						frmMain->TestResult = false;
						frmMain->Panel_lan->Color = clRed;
						frmMain->Panel_lan->Caption = "FAIL";
						frmMain->Height = 289;
						frmMain->plErrMsg->Caption = "USB3.0 FAIL";
					}
				}else{
					//網路測試
					strcpy(zTestResult[1].name, "LAN");
					lan = ::CreateThread(0, 1024, LANExecute, (LPVOID) & zTestResult[1], 0,
						NULL);
						WaitForSingleObject(lan, INFINITE);
						CloseHandle(lan);
				}
			}
			TestTime = 0;

			frmMain->Refresh();
			Step = 2;
		break;
		case 2:
			if(PORT->Findfilemsg("TEST_TOOL\\infomation.txt","TEST ITEM", 3) != "AUTORUN_true"){
				frmMain->btn_set->Enabled = true;
				frmMain->TestWorking = false;
				//frmMain->btn_start->Enabled = false;
			}
			if(!PORT->FindDevice(deviceVPID)){
				frmMain->Panel_mac->Color = clWhite;
				frmMain->Panel_lan->Color = clWhite;
				frmMain->Panel_lan->Caption = "Wait";
				frmMain->pan_10->Color = clWhite;
				frmMain->pan_100->Color = clWhite;
				frmMain->pan_1000->Color = clWhite;
				frmMain->Height = 255;
				frmMain->plErrMsg->Caption = "";
				frmMain->lab_devicename->Caption = "";
				frmMain->current_mac->Caption = "未插入設備";
				frmMain->HaveDevice = false;
				frmMain->lab_time->Caption = 0;
				if(frmMain->ckbNoMAC->Checked) frmMain->N1Click(NULL);
				Step = 0;
			}
			break;
		}
		frmMain->Refresh();
		Sleep(1000);
	}
	CloseHandle(threadwork);
	return 1;
}
DWORD WINAPI LANExecute(LPVOID Param){
	st_ThreadParam *pParam;
	pParam = (st_ThreadParam*)Param;
	// 改用fping測速
	AnsiString PVID = PORT->GetLanPVID(lanname);
	if (PORT->ChangeLanSpeed(PVID, "{4d36e972-e325-11ce-bfc1-08002be10318}", lanname)){
		frmMain->Lan_test_result(1);
		pParam->result = 1;
		return 1;
	}
	else{
		frmMain->Lan_test_result(-1);
		pParam->result = -1;
		return -1;
	}
}
//---------------------------------------------------------------------------
void __fastcall TfrmMain::Lan_test_result(int result){
	switch(result) {
	case 1:
		Panel_lan->Color = clGreen;
		frmMain->Panel_lan->Caption = "PASS";
		break;
	case -1:
		frmMain->TestResult = false;
		Panel_lan->Color = clRed;
		frmMain->Panel_lan->Caption = "FAIL";
		break;
	default:
		frmMain->TestResult = false;
		Panel_lan->Color = clRed;
		frmMain->Panel_lan->Caption = "FAIL";
		break;
	}
}
void __fastcall TfrmMain::btn_startClick(TObject *Sender)
{
	Memo2->SetFocus();
	lab_time->Caption = "0";
	if(!TestWorking && !AutoTest){
		if(PORT->Findfilemsg("TEST_TOOL\\infomation.txt","TEST ITEM", 3) == "AUTORUN_true")
			AutoTest = true;
		else
			AutoTest = false;
		TestResult = true; //預設true  網路切速緊急停止會需要
		TestWorking = true;
		btn_set->Enabled = false;
		//初始元件
		Panel_mac->Color = clWhite;
		Panel_lan->Color = clWhite;
		frmMain->Panel_lan->Caption = "Wait";
		pan_10->Color = clWhite;
		pan_100->Color = clWhite;
		pan_1000->Color = clWhite;
		frmMain->Height = 255;
		if(AutoTest){
			btn_start->Caption = L"停止";
		}else{
			btn_start->Enabled = false;
		}
		// 呼叫LAN執行檔
		strcpy(zTestResult[0].name, "ThreadWork");
		threadwork = ::CreateThread(0, 1024, ThreadWorkExecute, (LPVOID) & zTestResult[0], 0,
			NULL);
	}else{
		AutoTest = false;
		TestWorking = false;
		TestResult = false;
		btn_set->Enabled = true;
		btn_start->Caption = L"開始";
	}
}
//---------------------------------------------------------------------------
void __fastcall TfrmMain::btn_setClick(TObject *Sender)
{
	Memo2->SetFocus();
	int MSBOXnum;
	SETBOX = new Tmessagebox_form(Application);
	SETBOX->Caption = L"請輸入設定金鑰";
	SETBOX->changeform(5, "");
	MSBOXnum = SETBOX->ShowModal();
	if (MSBOXnum == 3){
		frmInfo = new TfrmInfo(Application);
		if (frmInfo->ShowModal() == mrYes) // 輸入工號後主視窗顯現
		{
        	SETBOX->Caption = L"";
			SETBOX->changeform(4, "設定完成");
			MSBOXnum = SETBOX->ShowModal();
			LOADClick(NULL);
		}
	}else{
        SETBOX->Caption = L"";
		SETBOX->changeform(4, "金鑰錯誤");
		MSBOXnum = SETBOX->ShowModal();
	}
	delete SETBOX;
}

//---------------------------------------------------------------------------
void __fastcall TfrmMain::FormCreate(TObject *Sender)
{
/////////////////////////////////////////// 限制只能執行一次
	mx = CreateMutex( NULL, true, L"AbacusPosAP" );
	if(GetLastError()){
		Application->Terminate(); //Finsh Application
	}
	frmMain->N1Click(NULL);
///////////////////////////////////////////////////////////////////
	RUNTIME = FormatDateTime("yymmddhhmmss",Now());
	lanname = "NULL";
	int timeout = 0;
	lanname = PORT->GetLANName();
	if(lanname!="NULL")
	{
		deviceVPID = PORT->GetLanPVID(lanname);
		HaveDevice = true;
	}
	else
	{
		lab_devicename->Caption = "";
		current_mac->Caption = "未插入設備";
	}
}
//---------------------------------------------------------------------------


void __fastcall TfrmMain::LOADClick(TObject *Sender)
{
	AnsiString filemac;
	if(ResetMAC){
		filemac = new_mac->Caption;
	}else{
		filemac = PORT->Findfilemsg("TEST_TOOL\\infomation.txt",
						"MAC SITE", 1);
		new_mac->Caption = filemac;
	}
	Edit1->Text = filemac.SubString(0,2);
	Edit2->Text = filemac.SubString(4,2);
	Edit3->Text = filemac.SubString(7,2);
	Edit4->Text = filemac.SubString(10,2);
	Edit5->Text = filemac.SubString(13,2);
	Edit6->Text = filemac.SubString(16,2);
}
//---------------------------------------------------------------------------

void __fastcall TfrmMain::SAVEClick(TObject *Sender)
{
	AnsiString SS;
	SS.printf("%02X:%02X:%02X:%02X:%02X:%02X",MA5,MA4,MA3,MA2,MA1,MA0);
    Memo2->Lines->Add("Next MAC Address is "+SS);
	AnsiString totalmsg = ""; // 檔案內容
	ifstream imsgfile("TEST_TOOL\\infomation.txt");
	std::string CFGmsg;
	if (imsgfile.is_open()) {
		while (!imsgfile.eof()) {
			getline(imsgfile, CFGmsg);
			if (strstr(CFGmsg.c_str(), "MAC SITE")) {
				totalmsg = totalmsg + AnsiString(CFGmsg.c_str()) + "\n";
				getline(imsgfile, CFGmsg);
				totalmsg = totalmsg + SS + "\n";
			}else
				totalmsg = totalmsg + AnsiString(CFGmsg.c_str()) + "\n";
		}
		imsgfile.close();
	}
	// 寫入檔案
	ofstream omsgfile("TEST_TOOL\\infomation.txt");
	omsgfile << totalmsg.c_str();
	omsgfile.close();
}
//---------------------------------------------------------------------------


void __fastcall TfrmMain::Memo2KeyPress(TObject *Sender, wchar_t &Key)
{
	if(btn_start->Enabled && Key == VK_RETURN && !TestWorking)
		btn_start->Click();
}
//---------------------------------------------------------------------------




void __fastcall TfrmMain::SaveLogClick(TObject *Sender)
{
	AnsiString SS;
	SS=FormatDateTime("hhmmss",Now());
	SS=SS+"\t";
	/*if (TestOnly->Checked)
		{
		SS=SS+"*** TEST ONLY ***\t";
		}
	else
		{
		SS=SS+SETMAC+"\t";
		} */

	SS=SS+GETMAC+"\t";

	SS=SS+HOSTIP+"\t";

	SS=SS+DHCPIP+"\t";

	if (SpeedTest->Checked && PORT->Findfilemsg("TEST_TOOL\\infomation.txt",
					"TEST ITEM", 2)=="LAN_true") SS=SS+"1G\t";

	if (isEC)
		SS=SS+"isEC\t";
	else
		SS=SS+"noEC\t";

	//Memo1->Lines->Add(SS);

	SS=SS+"\n";
	SaveLogLing(LOGFILE,SS);

	TIniFile *ini;
	ini = new TIniFile(INIFILE.c_str());
	//ini->WriteString("SYSTEM","XML File Web",Edit11->Text);
	ini->WriteString("MAC Address","MAC1",Edit1->Text);
	ini->WriteString("MAC Address","MAC2",Edit2->Text);
	ini->WriteString("MAC Address","MAC3",Edit3->Text);
	ini->WriteString("MAC Address","MAC4",Edit4->Text);
	ini->WriteString("MAC Address","MAC5",Edit5->Text);
	ini->WriteString("MAC Address","MAC6",Edit6->Text);
	ini->WriteString("MAC Address","MAC7",Edit7->Text);
	ini->WriteString("MAC Address","MAC8",Edit8->Text);
	ini->WriteString("MAC Address","MAC9",Edit9->Text);
	delete ini;
}
//---------------------------------------------------------------------------


void SaveLogLing(AnsiString FileName,AnsiString FileLine)
{
	fp = fopen(FileName.c_str(),"a+");
	fseek( fp, 0, SEEK_END);
	fwrite(FileLine.c_str(),FileLine.Length(),1,fp); //寫入一筆資料
	fclose(fp);
}

void __fastcall TfrmMain::FormClose(TObject *Sender, TCloseAction &Action)
{
	ReleaseMutex(mx);
}
//---------------------------------------------------------------------------
void __fastcall TfrmMain::TestTimeTimerTimer(TObject *Sender)
{
	if(frmMain->Panel_lan->Caption == "Testing")
	{
		if(TestTime == 0)
			TestTime = GetTickCount();
		lab_time->Caption = AnsiString((GetTickCount()-TestTime)/1000);
	}
}
//---------------------------------------------------------------------------


void __fastcall TfrmMain::N1Click(TObject *Sender)
{
	AnsiString temppath, temp, LANnum;
	AnsiString lanGUID = "{4d36e972-e325-11ce-bfc1-08002be10318}";
	TRegistry *reg = new TRegistry();
	reg->RootKey = HKEY_LOCAL_MACHINE;
	for (int i = 0; i <= 9999; i++) {
	//路徑名稱補0
		if (i < 10)
			LANnum = "000" + (AnsiString)i;
		if (i >= 10 && i < 100)
			LANnum = "00" + (AnsiString)i;
		if (i >= 100 && i < 1000)
			LANnum = "0" + (AnsiString)i;
		if (i >= 1000 && i < 10000)
			LANnum = (AnsiString)i;
		temppath = "SYSTEM\\CurrentControlSet\\Control\\Class\\" + lanGUID +
			"\\" + LANnum;
		reg->CloseKey();
		reg->OpenKey(temppath.c_str(), false);
		long tollnum = reg->InstanceSize();
		AnsiString tempDeviceID = (AnsiString)reg->ReadString("DriverDesc");

		if(tempDeviceID.Pos("Realtek USB")){
			if(reg->ValueExists ("NetworkAddress"))
				reg->DeleteValue("NetworkAddress");
		}
	}
	reg->CloseKey();
	delete reg;
}
//---------------------------------------------------------------------------

void __fastcall TfrmMain::ckbNoMACClick(TObject *Sender)
{
	N1Click(NULL);
}
//---------------------------------------------------------------------------

